---
title: "Intro to Data Analysis with R: Session 1"
subtitle: UCI Data Science Initiative
date: "October 20, 2017"
#author: "Emily Smith"
output: slidy_presentation
smaller: yes
---

```{r,echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
library(ggplot2)
```


## Schedule

+ Session 1: Fundamentals of R
+ Exercise 1
+ *Break*
+ Session 2: Functions and Exploratory Data Analysis
+ Exercise 2
+ *Lunch*
+ Session 3: Linear Regression
+ Exercise 3
+ *Break*
+ Session 4: Logistic Regression 


## Introduction 
+ Please ask questions during lectures & throughout the day!
+ To access this presentation and the code used during the workshop please visit the [IDA-with-R GitHub page](https://github.com/UCIDataScienceInitiative/IDA-with-R).
  

## Session 1 - Agenda

1. What is R?
2. Intro to RStudio
3. Data Structures
4. Subsetting & Indexing


## What is R?
+ R is a free software environment for statistical computing and graphics
    + See http://www.r-project.org/ for more info 
+ R compiles and runs on a wide variety of UNIX platforms, Windows and Mac OS
+ R is open-source and free
+ R is fundamentally a command-driven system
+ R is an object-oriented programming language 
    + Everything in R is an object (data, functions, etc.)
+ R is highly extendable
    + You can write your own custom functions
    + There are over 11,000 free add-on packages


## R Studio
+ RStudio is a free and open source integrated development environment (IDE) for R.
+ To download RStudio please visit: http://rstudio.org/
+ Please note that you must have R already installed before installing R Studio.


## Fundamentals of R
+ When you type commands at the prompt '>' and hit ENTER
    + R tries to interpret what you've asked it to do (evaluation)
    + If it understands what you've written, it does it (execution)
    + If it doesn't, it will likely give you an error or a warning
+ Some commands trigger R to print to the screen, others don't
+ If you type an incomplete command, R will usually respond by changing the command prompt to the '+' character
    + Hit ESC on a MAC to cancel
    + Type _Ctrl_ + *C* on Windows and Linux to cancel


## Data Types in R
+ R has 5 main atomic data types:
    + Numeric
    + Character
    + Logical
    + Integer
    + Complex


## Data Structures in R
1. One-dimensional:
    + Vectors
2. Multi-dimensional:
    + Matrices
    + Data frames

&nbsp;

+ Everything in R is an object
+ Objects can have attributes
    + e.g., names, dimension, length


## Vectors in R
+ A vector is the most basic object in R
+ It is one-dimensional; its single dimension is its length
+ A vector of length *n* has *n* cells
+ Each cell can hold a single value, like a numeric or string value
    + In general, vectors can only hold ONE type of data 
  
```{r echo=TRUE}
numVec <- c(2,3,4)      # <- is the assigning operator
numVec
```


## Examples of Character and Logical Vectors
```{r echo=TRUE}
charVec <- c("red", "green", "blue")
charVec

logVec <- c(TRUE, FALSE, FALSE, T, F)
logVec

```


## Special Values
There are some special values in R:

  + ```Inf```: infinity
  + ```NaN```: "Not a number"
  
```{r echo=TRUE}
a <- Inf; b <- 0
rslt <- c(b/a, a/a)
rslt
```


## Data Type Coercion
+ In general, vectors CANNOT have mixed types of data
+ If you create a vector with more than one type of data, R will automatically coerce it to a single type

```{r echo=TRUE}
numCharVec <- c(3.14, "a")
numCharVec                 
```

+ Explicitly coerce objects from one type to another using the function ```as()```
    + Be careful about warnings; always check to make sure the coercion is correct!

```{r echo=TRUE}
numVec <- 1:10
numToChar <- as(numVec, "character")
numToChar
```


## Factors
+ A factor is a vector object used to specify a discrete classification (categorical values)
+ Factors can be ordered or un-ordered
+ Levels of a factor are better labeled (self-descriptive)
    + Consider gender as (0, 1) as opposed to labeled ("F", "M")
```{r echo=TRUE}
Gender <- rep(c("Female", "Male"), times = 3)
Gender
GenderFac1 <- factor(Gender)
GenderFac1
```


## Missing Values
+ There are two kinds of missing values in R:
    + ```NaN```: stands for "Not a Number" and is a missing value produced by numerical computation
    + ```NA```: stands for "Not Available" and is used when a value is missing
+ ```NaN``` is also considered as NA (the reverse is NOT true)
```{r echo=TRUE}
a <- c(1,2)
a[3]

b <- 0/0
b
```


## Missing Values, contd.
```is.na()``` and ```is.nan()``` are functions that indicate which value(s) of an object are missing
```{r echo=TRUE}
vec <- c(1, NA, 3, NaN, NA, 5, NaN)
is.na(vec)
is.nan(vec)
```


## Matrices
+ A matrix is a special case of a vector (matrices have dimension)
    + Like vectors, all elements of a matrix should be of the same data type

```{r echo=TRUE}
myMat <- matrix(nrow = 2, ncol = 4)
myMat
```

+ Matrices are filled column-wise (unless otherwise specified)

```{r echo=TRUE}
myMat <- matrix(nrow = 2, ncol = 4, data = 1:8)
myMat
```


## Other Ways to Create a Matrix
+ Intuitively, matrices seem to be a combination of vectors that are put next to each other (either column-wise or row-wise)

+ ```rbind()``` and ```cbind()``` (row bind and column bind) achieve this 
```{r echo=TRUE}
vec1 <- 1:4
vec2 <- 5:8
vec3 <- 9:12
colMat <- cbind(vec1, vec2, vec3)
colMat
```


## Other Ways to Create a Matrix, contd.
```{r echo=TRUE}
rowMat <- rbind(vec1, vec2, vec3)
rowMat
```


## Data Frames:
+ A data frame looks very similar to a matrix; however, different columns in a data frame can be different data types
+ Often, data used for analysis will be in the form of a data frame
+ Let's learn how to read a data frame into R


## Reading Data into R
+ Main functions for reading data into R:

1. ```read.table()```, ```read.csv()```: to read tabular data 
2. ```readLines()```: to read lines of a text file
3. ```source()```, ```dget()```: to read R code
4. ```load()```: to read saved workspaces

+ Only ```read.table()``` and ```read.csv()``` will be covered today. 


## Reading Data into R, contd.
+ ```read.table()``` is the most commonly used function to read data in R
    + Type ```?read.table``` in your R console to see the important arguments in the function
+ ```read.csv()``` is intended for reading comma separated value files 
    + Equivalent to read.table() with sep = "," and header = TRUE
    
    
## ```read.table()```
```{r echo = TRUE, eval=TRUE}
prestige <- read.table(file = "./data/prestige.csv", sep=",", header = TRUE, row.names=1)
class(prestige)
head(prestige)
```

## Data Frame
+ The prestige data frame has named rows. We can use the function ```row.names()``` to see the names of each row. 

```{r echo = TRUE, eval=TRUE}
head(row.names(prestige))
```


## Subsetting
+ Now that we have a data frame loaded, let's learn about subsetting data frames and vectors
+ Consider two main operators to take a subset of an object
    + [ ] single brackets return an object of the same class as the original object
    + $ used primarily for data frames
        + We use $ when selecting an element by name
+ [ ] allows us to select more than one element 
+ $ allows us to select only one 


## Subsetting Vectors
```{r echo=TRUE}
vec <- 1:10
vec[3]
```
Single brackets allow us to select more than one element of an object
```{r echo=TRUE}
vec[1:3]
vec[c(2,4,6)]
```


## Subsetting Data Frames
+ We also use the single square brackets to subset data frames
    + In the square brackets, the first position refers to the row(s) and the second position refers to the column(s)
```{r echo=TRUE}
prestige[1:2,]
prestige[1,2]

```


## Subsetting Data Frames
+ We use $ when selecting an element by name
    + This is commonly used to subset a column of a data frame
```{r echo=TRUE}
head(prestige$education)
```


## Index Vector
+ Another way to select more than one element from an object is by using index vectors
    + An index vector is a vector of indices that is used to select a subset of another vector (or matrix)
+ We will cover three types of index vectors: 
    1. Logical index vector
    2. Vector of positive integers
    3. Vector of character strings


## 1. Logical Index Vector
+ A vector of TRUE/FALSE values that should be the same length as the vector from which we are subsetting. 
    + Values corresponding to TRUE in the index vector are selected
+ We can treat ```is.na()``` as an index vector to subset rows containing NAs

```{r echo=TRUE}
logIndVec <- is.na(prestige$type)
head(logIndVec)
prestige[logIndVec,]
```


## 2. Index Vector of Positive Integers
+ A vector of positive integers corresponding to the elements you want to subset
+ We can use the function ```which()``` along with ```is.na()``` to create this index vector
```{r echo=TRUE}
posIndVec <- which(is.na(prestige$type))
posIndVec
prestige[posIndVec,]
```


## 3. Vector of Character Strings
+ If an object has a name attribute, we can take a subset of the vector by calling the names of the elements
+ For example, we can use this to take a subset of the columns of the prestige data
```{r echo=TRUE}
head(prestige[,c("education", "income")])
```

## Sorting

+ We can use the ```order()``` function along with the subsetting operators to sort a data frame by a specific column. 
+ Let's sort the prestige data in ascending order by education. 
```{r echo=TRUE}
sort.index <- order(prestige$education, decreasing = FALSE)
prestige.sorted <- prestige[sort.index,]
head(prestige.sorted)
```

## Subsetting Example
+ Let's see an example of how subsetting might be use to manipulate data. 
+ We will replace some of the missing values in the type column with "bc"
+ Recall that we used an index vector to subset the rows of prestige that contain NAs

```{r echo=TRUE}
ind <- which(is.na(prestige$type)) 
prestige[ind,]
rbind(index=ind, name=rownames(prestige)[ind])
```

## Subsetting Example

+ We will replace the last three NAs with "bc" (blue collar)
```{r echo=TRUE}
ind.ch <- ind[2:4]
prestige[ind.ch, "type"] <- rep("bc", 3)
summary(prestige$type)
```

+ Exclude any rows that still contain NA (one row for athletes)
```{r echo=TRUE}
prestige <- na.omit(prestige)
summary(prestige$type)
```

## Writing Data to File
+ We can use ```write.table()``` to write a data frame to file
+ Similar to ```read.table()```, but we now also specify the name of the data frame in addition to the path
    + ```write.csv``` is analagous to ```read.csv```
+ Let's write our updated prestige data to a new csv file

```{r echo=TRUE}
# write.table(prestige, "./data/prestige_v2.csv", sep = ",", header = TRUE, row.names = TRUE)
```



